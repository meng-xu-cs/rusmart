These are the minor changes that I have made to the code:

This file is not exhaustive and primarily contains the changes that are related to corner cases where changes might cause off-by-one errors or other issues.
1 - in file dt.rs of rusmart-smt-stdlib crate:
Previous code:
macro_rules! integer_from_literal {
    ($l:ty $(,$e:ty)* $(,)?) => {
        impl From<$l> for Integer {
            fn from(c: $l) -> Self {
                Self {
                    inner: Intern::new(BigInt::from(c)),
                }
            }
        }
        $(impl From<$e> for Integer {
            fn from(c: $e) -> Self {
                Self {
                    inner: Intern::new(BigInt::from(c)),
                }
            }
        })+
    };
}

New code:
macro_rules! integer_from_literal {
    ($l:ty $(,$e:ty)* $(,)?) => {
        impl From<$l> for Integer {
            fn from(c: $l) -> Self {
                Self {
                    inner: Intern::new(BigInt::from(c)),
                }
            }
        }
        $(impl From<$e> for Integer {
            fn from(c: $e) -> Self {
                Self {
                    inner: Intern::new(BigInt::from(c)),
                }
            }
        })*
    };
}



/// Test case for the checkout function.
/// Checks if the repository can be checked out to a non-existent directory, which should pass.
/// A question arises that if we can create a new git repository from the crate (like in test_git_repo_new where the crate directory had a commit hash) why can't we clone and checkout the crate instead of retrieving the workspace root.
/// In test_git_repo_new, the retreived hash is the same than the one from the workspace. However, the workspace is a git repo and the crate is not. So the crate cannot be cloned and checked out.
#[test]
fn test_git_repo_checkout() {
    // get the path to the workspace
    let path = find_workspace_root().unwrap();
    let mut repo = GitRepo::new(path, None).unwrap();

    let result = repo.checkout(Path::new("temp_checkout"));
    assert!(result.is_ok());

    // Cleanup
    fs::remove_dir_all("temp_checkout").unwrap();
}
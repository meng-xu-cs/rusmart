//! This is the only public module in the library crate.
//! It provides the arguments parsing and their corresponding actions.
//!

// ------------------------------------------------------------------------------------------------//

use anyhow::Result;
use clap::Subcommand;
use std::path::PathBuf;
// This module depends on all the other modules in the library crate.
use crate::dep::{DepState, Dependency};
use crate::dep_cvc5::DepCVC5;
use crate::dep_z3::DepZ3;

// ------------------------------------------------------------------------------------------------//

/// Enum representing available subcommands for the CLI
/// Two subcommands are defined: Reset and Deps.
/// Help is also a subcommand that is automatically generated by the clap crate.
/// 1) cargo run -- reset 2) cargo run -- deps .... 3) cargo run -- --help
/// For 1 and 2, there is no ambiguity between the cargo subcommand and the application subcommand as cargo does not have any subcommands with the same name.
/// so we can write cargo run reset and cargo run deps .... instead of cargo run -- reset and cargo run -- deps ....
#[derive(Subcommand)]
pub enum Command {
    // These descriptions are displayed in the help message when the user runs the cargo run -- --help command.
    /// Run cargo run -- reset to delete the studio directory
    Reset,

    // These descriptions are displayed in the help message when the user runs the cargo run -- --help command.
    /// Manage dependencies (subcommand is defined in DepArgs)
    /// for example> cargo run deps cvc5 build
    #[command(subcommand)]
    Deps(DepArgs),
}

/// Dependency subcommands: This argument defines whether to manage the Z3 or CVC5 dependency.
#[derive(Subcommand)]
// [allow(clippy::upper_case_acronyms)] attribute is used to suppress the warning for the Z3 and CVC5 acronyms, which are in uppercase.
#[allow(clippy::upper_case_acronyms)]
pub enum DepArgs {
    /// Solver Z3
    #[command(subcommand)]
    Z3(DepAction),
    /// Solver CVC5
    #[command(subcommand)]
    CVC5(DepAction),
}

impl DepArgs {
    /// Run the embedded dependency action for the Z3 or CVC5 dependency.
    pub fn run(self) -> Result<()> {
        match self {
            Self::Z3(action) => action.run_internal::<DepZ3>(),
            Self::CVC5(action) => action.run_internal::<DepCVC5>(),
        }
    }
}

/// Dependency actions type: Config and Build
#[derive(Subcommand)]
pub enum DepAction {
    /// Config the dependency
    Config,

    /// Build the dependency
    Build {
        /// Force the build to proceed
        /// This parameter can be added as the long version (--force) or short (-f).
        #[arg(short, long)]
        force: bool,
    },
}

impl DepAction {
    /// Running the dependency actions
    fn run_internal<T: Dependency>(self) -> Result<()> {
        let state: DepState<T> = DepState::new()?;
        match self {
            DepAction::Config => state.list_configurations()?,
            DepAction::Build { force } => state.build(force)?,
        }
        Ok(())
    }
}

/// Get the dst path to an artifact or return an error
/// Depending on whether the artifact is a package or a scratch artifact, the function will return the path to the package or create a scratch artifact and return the path to it.
/// This function may be time-consuming as it may need to build the artifact. (not tested)
fn artifact<T: Dependency>() -> Result<PathBuf> {
    let pkg = match DepState::<T>::new()? {
        DepState::Package(package) => package,
        DepState::Scratch(scratch) => scratch.make()?,
    };
    Ok(pkg.export())
}

/// Get the path to an artifact, panics if unable to obtain the path
/// not tested as it may need to build the artifact
fn expect_artifact<T: Dependency>() -> PathBuf {
    match artifact::<T>() {
        Ok(r) => r,
        Err(e) => panic!("unexpected error: {}", e),
    }
}

/// Force to retrieve the path to z3
/// not tested as it may need to build the artifact
pub fn expect_z3() -> PathBuf {
    expect_artifact::<DepZ3>()
}

/// Force to retrieve the path to cvc5
/// not tested as it may need to build the artifact
pub fn expect_cvc5() -> PathBuf {
    expect_artifact::<DepCVC5>()
}

// ---------------------------------------------TESTS------------------------------------------------- //

#[cfg(test)]
mod tests {
    use super::*;

    // In all the tests, we only check the configuration action as the build action is computationally expensive and time-consuming. Therefore, functions like `make` and `build` are not tested.
    #[test]
    /// Test the run function for the DepArgs enum with the Z3 dependency and the Config action.
    fn test_run_dep_args_z3() {
        let args = DepArgs::Z3(DepAction::Config);
        let res = args.run();

        assert!(res.is_ok());
    }

    #[test]
    /// Test the run function for the DepArgs enum with the CVC5 dependency and the Config action.
    fn test_run_dep_args_cvc5() {
        let args = DepArgs::CVC5(DepAction::Config);
        let res = args.run();

        assert!(res.is_ok());
    }

    #[test]
    /// Test the run_internal function for the DepAction enum with the Z3 dependency and the Config action.
    fn test_run_internal_dep_action_z3() {
        let dep_action = DepAction::Config;
        let res = dep_action.run_internal::<DepZ3>();

        assert!(res.is_ok());
    }

    #[test]
    /// Test the run_internal function for the DepAction enum with the CVC5 dependency and the Config action.
    fn test_run_internal_dep_action_cvc5() {
        let dep_action = DepAction::Config;
        let res = dep_action.run_internal::<DepCVC5>();

        assert!(res.is_ok());
    }
}
